Some guiding principles
=======================
- Text is a first class citizen in this 3D world
- Give users a feeling of control: don't hide things





MVC vs visualizer/editor
========================
- This project is a visualizer and an editor.
- It aims at visualizing a lot of different things:
    1. files and folders
    2. a project hierarchy
    3. a live runtime state of a program
    4. system metrics
- I especially consider 3. to be the main goal, with 1. being a necessary intermediate step


File/scene structure
====================
- Save as many things as possible as directly usable python libraries
- Have a `init_scene.py` used to initialize the scene


User story
==========
We collaborate on a git tree.
I have local modifications I want to show another person
I want to show the result of the execution
Together we change the file content until we are happy
We end up doing a git commit


Networking
==========
I wanted to keep it simple, but arbitrary execution makes it hard, we will need a level of isolation and 2 levels of
networking:

unsafe link:  Remote server <-> local nsjail
safe link:    Local nsjail <-> GUI client

The safe link only transmits:
- pose information
- texture information
- creation of SceneNodes from a fixed vocabulary
- updates of fields from a fixed list and with a fixed list of possible types
- deletion of SceneNodes

All in-game code execution happens in the nsjail.


Simple protocol (will do for now but needs extending)
---------------
Outdated: look at the message.proto definition

client -> Server:
- knockknock: "Hi! I would like to see your scene" (placeholder for auth)
- sendall: "Send me initial states of the objects in the scene"
- sendmenewid: "Create a new object and send me its ID"
- action <id> <UserAction>: "The user did this action on this object"
Server -> Client
- newobjid <id>
Server <-> Client
- state <id> <state>: "Here is the full state of obj <id>"
- update <id> <field> <value>: "Update field's value on obj <id>"
- remove <id>: "Obj got deleted"



Persistence
-----------
Every player runs a local server and a local client. The local server is a nsjail where the arbitrary code is executed.
It is possible to subsribe to the events of a remote server for the local client, that will then merge both states in
the scenegraph.

Servers decide which clients are allowed to spectate (receive updates) and act (emit updates).

Clients can decide to "copy" remote objects locally by cloning them into their local scenegraph.

Root
|
+-Remote
|   +--RemoteRoot1
|   |   +--RemoteCamera1
|   |   +--RemoteNode1
|   +--RemoteRoot2
|       +--RemoteCamera2
+-Local
    +--LocalCamera
    +--LocalNodeTree

Security
--------
Remote server <-> local nsjail
Local nsjail <-> GUI client

Security model: we only run "in-game" python code inside the nsjail. The current scenegraph is all that is at risk.
The GUI client/nsjail host is in charge of backuping, managing the disk sync.


GUI
===
Layout management



3D Objects interactions
========================
- The user interacts with objects by sending them actions. E.g. 'activate', 'edit', 'open'.
- There is a mapping between key/clicks events and actions
    - Several actions can be attributed to the same key
    - A default mapping is provided
- Behaviors maintain a mapping between actions and handlers
- Movement keys (that are active as long as they are pressed) are different types of events
- All actions can have "click" coordinates. Pass it as action arguments, not as .context member as
it can get ugly in case of delays

Event dispatch order:
1. Global behaviors
2. Current camera behaviors
3. Grabbed object
4. Hovered object

Can't we just do with 1 and 2 and put the grab and hovering in a camera behavior?

Code Snippet
============
Code snippets are pieces of code that can be put inside CodeSnippetReceivers. Note that the CodeSnippet
object only exists when the snipper is freefloating. Otherwise it is just a piece of text. The clipboard
actions can be applied to them:

'X' takes the snippet:
    - If it was inside a Receiver, the Receiver becomes empty and the code snippet is now grabbed
    - If it was free floating, it is the same as grabbing the object
'C' duplicates the snippet as a free floating object and the duplicate is now grabbed. If something was
grabbed, this action is not possible.
'V' drops the snippet:
    - If a Receiver is currently hovered, the text is set in the receiver and the grabbed object is destroyed
    - Otherwise the freefloating object is ungrabbed.



HUD
===
A hud describes the current object type and the possible actions to it